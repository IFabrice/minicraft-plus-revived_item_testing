


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Renderer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">minicraft.core</a>
</div>

<h1>Coverage Summary for Class: Renderer (minicraft.core)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Renderer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (1/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.4%
  </span>
  <span class="absValue">
    (10/296)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package minicraft.core;
&nbsp;
&nbsp;import minicraft.core.CrashHandler.ErrorInfo;
&nbsp;import minicraft.core.io.Localization;
&nbsp;import minicraft.core.io.Settings;
&nbsp;import minicraft.entity.furniture.Bed;
&nbsp;import minicraft.entity.mob.AirWizard;
&nbsp;import minicraft.entity.mob.ObsidianKnight;
&nbsp;import minicraft.entity.mob.Player;
&nbsp;import minicraft.gfx.Color;
&nbsp;import minicraft.gfx.Ellipsis;
&nbsp;import minicraft.gfx.Ellipsis.DotUpdater.TickUpdater;
&nbsp;import minicraft.gfx.Ellipsis.SmoothEllipsis;
&nbsp;import minicraft.gfx.Font;
&nbsp;import minicraft.gfx.FontStyle;
&nbsp;import minicraft.gfx.MinicraftImage;
&nbsp;import minicraft.gfx.Point;
&nbsp;import minicraft.gfx.Screen;
&nbsp;import minicraft.gfx.SpriteLinker;
&nbsp;import minicraft.gfx.SpriteLinker.LinkedSprite;
&nbsp;import minicraft.gfx.SpriteLinker.SpriteType;
&nbsp;import minicraft.item.Items;
&nbsp;import minicraft.item.PotionType;
&nbsp;import minicraft.item.ToolItem;
&nbsp;import minicraft.item.ToolType;
&nbsp;import minicraft.item.WateringCanItem;
&nbsp;import minicraft.level.Level;
&nbsp;import minicraft.screen.LoadingDisplay;
&nbsp;import minicraft.screen.Menu;
&nbsp;import minicraft.screen.QuestsDisplay;
&nbsp;import minicraft.screen.RelPos;
&nbsp;import minicraft.screen.SignDisplayMenu;
&nbsp;import minicraft.screen.TutorialDisplayHandler;
&nbsp;import minicraft.screen.entry.ListEntry;
&nbsp;import minicraft.screen.entry.StringEntry;
&nbsp;import minicraft.util.Quest;
&nbsp;import minicraft.util.Quest.QuestSeries;
&nbsp;
&nbsp;import javax.imageio.ImageIO;
&nbsp;
&nbsp;import java.awt.Canvas;
&nbsp;import java.awt.Graphics2D;
&nbsp;import java.awt.geom.AffineTransform;
&nbsp;import java.awt.image.AffineTransformOp;
&nbsp;import java.awt.image.BufferStrategy;
&nbsp;import java.awt.image.BufferedImage;
&nbsp;import java.awt.image.DataBufferInt;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.time.format.DateTimeFormatter;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;public class Renderer extends Game {
<b class="nc">&nbsp;	private Renderer() {</b>
<b class="nc">&nbsp;	}</b>
&nbsp;
<b class="fc">&nbsp;	public static int HEIGHT = 192;</b>
<b class="fc">&nbsp;	public static int WIDTH = 288;</b>
<b class="fc">&nbsp;	static float SCALE = 3;</b>
&nbsp;
&nbsp;	public static Screen screen; // Creates the main screen
<b class="fc">&nbsp;	public static SpriteLinker spriteLinker = new SpriteLinker(); // The sprite linker for sprites</b>
&nbsp;
<b class="fc">&nbsp;	static Canvas canvas = new Canvas();</b>
&nbsp;	private static BufferedImage image; // Creates an image to be displayed on the screen.
&nbsp;
&nbsp;
<b class="fc">&nbsp;	public static boolean readyToRenderGameplay = false;</b>
<b class="fc">&nbsp;	public static boolean showDebugInfo = false;</b>
&nbsp;
<b class="fc">&nbsp;	public static SignDisplayMenu signDisplayMenu = null;</b>
&nbsp;
<b class="fc">&nbsp;	private static Ellipsis ellipsis = new SmoothEllipsis(new TickUpdater());</b>
&nbsp;
<b class="fc">&nbsp;	private static int potionRenderOffset = 0;</b>
&nbsp;
&nbsp;	private static LinkedSprite hudSheet;
&nbsp;
&nbsp;	public static MinicraftImage loadDefaultSkinSheet() {
&nbsp;		MinicraftImage skinsSheet;
&nbsp;		try {
&nbsp;			// These set the sprites to be used.
<b class="nc">&nbsp;			skinsSheet = MinicraftImage.createDefaultCompatible(ImageIO.read(Objects.requireNonNull(Game.class.getResourceAsStream(&quot;/resources/textures/skins.png&quot;))));</b>
<b class="nc">&nbsp;		} catch (NullPointerException e) {</b>
&nbsp;			// If a provided InputStream has no name. (in practice meaning it cannot be found.)
<b class="nc">&nbsp;			CrashHandler.crashHandle(e, new ErrorInfo(&quot;Sprite Sheet Not Found&quot;, ErrorInfo.ErrorType.UNEXPECTED, true, &quot;A sprite sheet was not found.&quot;));</b>
<b class="nc">&nbsp;			return null;</b>
<b class="nc">&nbsp;		} catch (IOException | IllegalArgumentException | MinicraftImage.MinicraftImageDimensionIncompatibleException e) {</b>
&nbsp;			// If there is an error reading the file.
<b class="nc">&nbsp;			CrashHandler.crashHandle(e, new ErrorInfo(&quot;Sprite Sheet Could Not be Loaded&quot;, ErrorInfo.ErrorType.UNEXPECTED, true, &quot;Could not load a sprite sheet.&quot;));</b>
<b class="nc">&nbsp;			return null;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		return skinsSheet;</b>
&nbsp;	}
&nbsp;
&nbsp;	public static void initScreen() {
<b class="nc">&nbsp;		image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);</b>
<b class="nc">&nbsp;		screen = new Screen(image);</b>
&nbsp;		//lightScreen = new Screen();
&nbsp;
<b class="nc">&nbsp;		hudSheet = new LinkedSprite(SpriteType.Gui, &quot;hud&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		canvas.createBufferStrategy(3);</b>
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;
&nbsp;	/**
&nbsp;	 * Renders the current screen. Called in game loop, a bit after tick().
&nbsp;	 */
&nbsp;	public static void render() {
<b class="nc">&nbsp;		if (screen == null) return; // No point in this if there&#39;s no gui... :P</b>
&nbsp;
<b class="nc">&nbsp;		screen.clear(0);</b>
&nbsp;
<b class="nc">&nbsp;		if (readyToRenderGameplay) {</b>
<b class="nc">&nbsp;			renderLevel();</b>
<b class="nc">&nbsp;			if (player.renderGUI) renderGui();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (currentDisplay != null) // Renders menu, if present.</b>
<b class="nc">&nbsp;			currentDisplay.render(screen);</b>
&nbsp;
<b class="nc">&nbsp;		if (!canvas.hasFocus())</b>
<b class="nc">&nbsp;			renderFocusNagger(); // Calls the renderFocusNagger() method, which creates the &quot;Click to Focus&quot; message.</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;		BufferStrategy bs = canvas.getBufferStrategy(); // Creates a buffer strategy to determine how the graphics should be buffered.</b>
<b class="nc">&nbsp;		Graphics2D g = (Graphics2D) bs.getDrawGraphics(); // Gets the graphics in which java draws the picture</b>
<b class="nc">&nbsp;		g.clearRect(0, 0, canvas.getWidth(), canvas.getHeight()); // Draws a rect to fill the whole window (to cover last?)</b>
&nbsp;
&nbsp;
&nbsp;
&nbsp;		// Flushes the screen to the renderer.
<b class="nc">&nbsp;		screen.flush();</b>
&nbsp;
&nbsp;		// Scale the pixels.
<b class="nc">&nbsp;		int ww = getWindowSize().width;</b>
<b class="nc">&nbsp;		int hh = getWindowSize().height;</b>
&nbsp;
&nbsp;		// Get the image offset.
<b class="nc">&nbsp;		int xOffset = (canvas.getWidth() - ww) / 2 + canvas.getParent().getInsets().left;</b>
<b class="nc">&nbsp;		int yOffset = (canvas.getHeight() - hh) / 2 + canvas.getParent().getInsets().top;</b>
&nbsp;
&nbsp;		// Draw the image on the window.
<b class="nc">&nbsp;		g.drawImage(image, xOffset, yOffset, ww, hh, null);</b>
&nbsp;
&nbsp;		// Release any system items that are using this method. (so we don&#39;t have crappy framerates)
<b class="nc">&nbsp;		g.dispose();</b>
&nbsp;
&nbsp;		// Make the picture visible.
<b class="nc">&nbsp;		bs.show();</b>
&nbsp;
&nbsp;		// Screen capturing.
<b class="nc">&nbsp;		if (Updater.screenshot &gt; 0) {</b>
<b class="nc">&nbsp;			new File(Game.gameDir + &quot;/screenshots/&quot;).mkdirs();</b>
<b class="nc">&nbsp;			int count = 1;</b>
<b class="nc">&nbsp;			LocalDateTime datetime = LocalDateTime.now();</b>
<b class="nc">&nbsp;			String stamp = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd_HH.mm.ss&quot;).format(datetime);</b>
<b class="nc">&nbsp;			File file = new File(String.format(&quot;%s/screenshots/%s.png&quot;, Game.gameDir, stamp));</b>
<b class="nc">&nbsp;			while (file.exists()) {</b>
<b class="nc">&nbsp;				file = new File(String.format(&quot;%s/screenshots/%s_%s.png&quot;, Game.gameDir, stamp, count));</b>
<b class="nc">&nbsp;				count++;</b>
&nbsp;			}
&nbsp;
&nbsp;			try { // https://stackoverflow.com/a/4216635
<b class="nc">&nbsp;				int w = image.getWidth();</b>
<b class="nc">&nbsp;				int h = image.getHeight();</b>
<b class="nc">&nbsp;				BufferedImage before = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);</b>
<b class="nc">&nbsp;				before.getRaster().setRect(image.getData());</b>
<b class="nc">&nbsp;				int scale = (Integer) Settings.get(&quot;screenshot&quot;);</b>
&nbsp;				// BufferedImage after = BigBufferedImage.create(scale * w, scale * h, BufferedImage.TYPE_INT_RGB);
<b class="nc">&nbsp;				AffineTransform at = new AffineTransform();</b>
<b class="nc">&nbsp;				at.scale(scale, scale); // Setting the scaling.</b>
<b class="nc">&nbsp;				AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);</b>
&nbsp;
&nbsp;				// Use this solution without larger scales which use up a lot of memory.
&nbsp;				// With scale 20, up to around 360MB overall RAM use.
<b class="nc">&nbsp;				BufferedImage after = scaleOp.filter(before, null);</b>
<b class="nc">&nbsp;				ImageIO.write(after, &quot;png&quot;, file);</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				CrashHandler.errorHandle(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			Updater.screenshot--;</b>
&nbsp;		}
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;
&nbsp;	private static void renderLevel() {
<b class="nc">&nbsp;		Level level = levels[currentLevel];</b>
<b class="nc">&nbsp;		if (level == null) return;</b>
&nbsp;
<b class="nc">&nbsp;		int xScroll = player.x - Screen.w / 2; // Scrolls the screen in the x axis.</b>
<b class="nc">&nbsp;		int yScroll = player.y - (Screen.h - 8) / 2; // Scrolls the screen in the y axis.</b>
&nbsp;
&nbsp;		// Stop scrolling if the screen is at the ...
<b class="nc">&nbsp;		if (xScroll &lt; 0) xScroll = 0; // ...Left border.</b>
<b class="nc">&nbsp;		if (yScroll &lt; 0) yScroll = 0; // ...Top border.</b>
<b class="nc">&nbsp;		if (xScroll &gt; level.w * 16 - Screen.w) xScroll = level.w * 16 - Screen.w; // ...Right border.</b>
<b class="nc">&nbsp;		if (yScroll &gt; level.h * 16 - Screen.h) yScroll = level.h * 16 - Screen.h; // ...Bottom border.</b>
<b class="nc">&nbsp;		if (currentLevel &gt; 3) { // If the current level is higher than 3 (which only the sky level (and dungeon) is)</b>
<b class="nc">&nbsp;			MinicraftImage cloud = spriteLinker.getSheet(SpriteType.Tile, &quot;cloud_background&quot;);</b>
<b class="nc">&nbsp;			for (int y = 0; y &lt; 28; y++)</b>
<b class="nc">&nbsp;				for (int x = 0; x &lt; 48; x++) {</b>
&nbsp;					// Creates the background for the sky (and dungeon) level:
<b class="nc">&nbsp;					screen.render(x * 8 - ((xScroll / 4) &amp; 7), y * 8 - ((yScroll / 4) &amp; 7), 0, 0, 0, cloud);</b>
&nbsp;				}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		level.renderBackground(screen, xScroll, yScroll); // Renders current level background</b>
<b class="nc">&nbsp;		level.renderSprites(screen, xScroll, yScroll); // Renders level sprites on screen</b>
&nbsp;
&nbsp;		// This creates the darkness in the caves
<b class="nc">&nbsp;		if ((currentLevel != 3 || Updater.tickCount &lt; Updater.dayLength / 4 || Updater.tickCount &gt; Updater.dayLength / 2) &amp;&amp; !isMode(&quot;minicraft.settings.mode.creative&quot;)) {</b>
<b class="nc">&nbsp;			int brightnessMultiplier = player.potioneffects.containsKey(PotionType.Light) ? 12 : 8; // Brightens all light sources by a factor of 1.5 when the player has the Light potion effect. (8 above is normal)</b>
<b class="nc">&nbsp;			level.renderLight(screen, xScroll, yScroll, brightnessMultiplier); // Finds (and renders) all the light from objects (like the player, lanterns, and lava).</b>
<b class="nc">&nbsp;			screen.overlay(currentLevel, xScroll, yScroll); // Overlays the light screen over the main screen.</b>
&nbsp;		}
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;
&nbsp;	/**
&nbsp;	 * Renders the main game GUI (hearts, Stamina bolts, name of the current item, etc.)
&nbsp;	 */
&nbsp;	private static void renderGui() {
&nbsp;		// This draws the black square where the selected item would be if you were holding it
<b class="nc">&nbsp;		if (!isMode(&quot;minicraft.settings.mode.creative&quot;) || player.activeItem != null) {</b>
<b class="nc">&nbsp;			for (int x = 10; x &lt; 26; x++) {</b>
<b class="nc">&nbsp;				screen.render(x * 8, Screen.h - 8, 5, 2, 0, hudSheet.getSheet());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// Shows active item sprite and name in bottom toolbar.
<b class="nc">&nbsp;		if (player.activeItem != null) {</b>
<b class="nc">&nbsp;			player.activeItem.renderHUD(screen, 10 * 8, Screen.h - 8, Color.WHITE);</b>
&nbsp;		}
&nbsp;
&nbsp;
&nbsp;		// This checks if the player is holding a bow, and shows the arrow counter accordingly.
<b class="nc">&nbsp;		if (player.activeItem instanceof ToolItem) {</b>
<b class="nc">&nbsp;			if (((ToolItem) player.activeItem).type == ToolType.Bow) {</b>
<b class="nc">&nbsp;				int ac = player.getInventory().count(Items.arrowItem);</b>
&nbsp;				// &quot;^&quot; is an infinite symbol.
<b class="nc">&nbsp;				if (isMode(&quot;minicraft.settings.mode.creative&quot;) || ac &gt;= 10000)</b>
<b class="nc">&nbsp;					Font.drawBackground(&quot;	x&quot; + &quot;^&quot;, screen, 84, Screen.h - 16);</b>
&nbsp;				else
<b class="nc">&nbsp;					Font.drawBackground(&quot;	x&quot; + ac, screen, 84, Screen.h - 16);</b>
&nbsp;				// Displays the arrow icon
<b class="nc">&nbsp;				screen.render(10 * 8 + 4, Screen.h - 16, 4, 1, 0, hudSheet.getSheet());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		ArrayList&lt;String&gt; permStatus = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		if (Updater.saving)</b>
<b class="nc">&nbsp;			permStatus.add(Localization.getLocalized(&quot;minicraft.display.gui.perm_status.saving&quot;, Math.round(LoadingDisplay.getPercentage())));</b>
<b class="nc">&nbsp;		if (Bed.sleeping()) permStatus.add(Localization.getLocalized(&quot;minicraft.display.gui.perm_status.sleeping&quot;));</b>
<b class="nc">&nbsp;		if (Bed.inBed(Game.player)) {</b>
<b class="nc">&nbsp;			permStatus.add(Localization.getLocalized(&quot;minicraft.display.gui.perm_status.sleep_cancel&quot;, input.getMapping(&quot;exit&quot;)));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (permStatus.size() &gt; 0) {</b>
<b class="nc">&nbsp;			FontStyle style = new FontStyle(Color.WHITE).setYPos(Screen.h / 2 - 25)</b>
<b class="nc">&nbsp;				.setRelTextPos(RelPos.TOP)</b>
<b class="nc">&nbsp;				.setShadowType(Color.DARK_GRAY, false);</b>
&nbsp;
<b class="nc">&nbsp;			Font.drawParagraph(permStatus, screen, style, 1);</b>
&nbsp;		}
&nbsp;
&nbsp;		// NOTIFICATIONS
&nbsp;
<b class="nc">&nbsp;		Updater.updateNoteTick = false;</b>
<b class="nc">&nbsp;		if (permStatus.size() == 0 &amp;&amp; notifications.size() &gt; 0) {</b>
<b class="nc">&nbsp;			Updater.updateNoteTick = true;</b>
<b class="nc">&nbsp;			if (notifications.size() &gt; 3) { // Only show 3 notifs max at one time; erase old notifs.</b>
<b class="nc">&nbsp;				notifications = notifications.subList(notifications.size() - 3, notifications.size());</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (Updater.notetick &gt; 180) { // Display time per notification.</b>
<b class="nc">&nbsp;				notifications.remove(0);</b>
<b class="nc">&nbsp;				Updater.notetick = 0;</b>
&nbsp;			}
<b class="nc">&nbsp;			List&lt;String&gt; print = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;			for (String n : notifications) {</b>
<b class="nc">&nbsp;				for (String l : Font.getLines(n, Screen.w, Screen.h, 0))</b>
<b class="nc">&nbsp;					print.add(l);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;			// Draw each current notification, with shadow text effect.
<b class="nc">&nbsp;			FontStyle style = new FontStyle(Color.WHITE).setShadowType(Color.DARK_GRAY, false)</b>
<b class="nc">&nbsp;				.setYPos(Screen.h * 2 / 5).setRelTextPos(RelPos.TOP, false);</b>
<b class="nc">&nbsp;			Font.drawParagraph(print, screen, style, 0);</b>
&nbsp;		}
&nbsp;
&nbsp;
&nbsp;		// SCORE MODE ONLY:
<b class="nc">&nbsp;		if (isMode(&quot;minicraft.settings.mode.score&quot;)) {</b>
<b class="nc">&nbsp;			int seconds = (int) Math.ceil(Updater.scoreTime / (double) Updater.normSpeed);</b>
<b class="nc">&nbsp;			int minutes = seconds / 60;</b>
<b class="nc">&nbsp;			int hours = minutes / 60;</b>
<b class="nc">&nbsp;			minutes %= 60;</b>
<b class="nc">&nbsp;			seconds %= 60;</b>
&nbsp;
&nbsp;			int timeCol;
<b class="nc">&nbsp;			if (Updater.scoreTime &gt;= 18000) timeCol = Color.get(0, 555);</b>
<b class="nc">&nbsp;			else if (Updater.scoreTime &gt;= 3600) timeCol = Color.get(330, 555);</b>
<b class="nc">&nbsp;			else timeCol = Color.get(400, 555);</b>
&nbsp;
<b class="nc">&nbsp;			Font.draw(Localization.getLocalized(&quot;minicraft.display.gui.score.time_left&quot;, hours &gt; 0 ? hours + &quot;h &quot; : &quot;&quot;, minutes, seconds), screen, Screen.w / 2 - 9 * 8, 2, timeCol);</b>
&nbsp;
<b class="nc">&nbsp;			String scoreString = Localization.getLocalized(&quot;minicraft.display.gui.score.current_score&quot;, player.getScore());</b>
<b class="nc">&nbsp;			Font.draw(scoreString, screen, Screen.w - Font.textWidth(scoreString) - 2, 3 + 8, Color.WHITE);</b>
&nbsp;
<b class="nc">&nbsp;			if (player.getMultiplier() &gt; 1) {</b>
<b class="nc">&nbsp;				int multColor = player.getMultiplier() &lt; Player.MAX_MULTIPLIER ? Color.get(-1, 540) : Color.RED;</b>
<b class="nc">&nbsp;				String mult = &quot;X&quot; + player.getMultiplier();</b>
<b class="nc">&nbsp;				Font.draw(mult, screen, Screen.w - Font.textWidth(mult) - 2, 4 + 2 * 8, multColor);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// TOOL DURABILITY STATUS
<b class="nc">&nbsp;		if (player.activeItem instanceof ToolItem) {</b>
&nbsp;			// Draws the text
<b class="nc">&nbsp;			ToolItem tool = (ToolItem) player.activeItem;</b>
<b class="nc">&nbsp;			int dura = tool.dur * 100 / (tool.type.durability * (tool.level + 1));</b>
<b class="nc">&nbsp;			int green = (int) (dura * 2.55f); // Let duration show as normal.</b>
<b class="nc">&nbsp;			Font.drawBackground(dura + &quot;%&quot;, screen, 164, Screen.h - 16, Color.get(1, 255 - green, green, 0));</b>
&nbsp;		}
&nbsp;
&nbsp;		// WATERING CAN CONTAINER STATUS
<b class="nc">&nbsp;		if (player.activeItem instanceof WateringCanItem) {</b>
&nbsp;			// Draws the text
<b class="nc">&nbsp;			WateringCanItem tin = (WateringCanItem) player.activeItem;</b>
<b class="nc">&nbsp;			int dura = tin.content * 100 / tin.CAPACITY;</b>
<b class="nc">&nbsp;			int green = (int) (dura * 2.55f); // Let duration show as normal.</b>
<b class="nc">&nbsp;			Font.drawBackground(dura + &quot;%&quot;, screen, 164, Screen.h - 16, Color.get(1, 255 - green, green, 0));</b>
&nbsp;		}
&nbsp;
&nbsp;		// This renders the potions overlay
<b class="nc">&nbsp;		if (player.showpotioneffects &amp;&amp; player.potioneffects.size() &gt; 0) {</b>
&nbsp;
&nbsp;			@SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;			Map.Entry&lt;PotionType, Integer&gt;[] effects = player.potioneffects.entrySet().toArray(new Map.Entry[0]);</b>
&nbsp;
&nbsp;			// The key is potion type, value is remaining potion duration.
<b class="nc">&nbsp;			if (!player.simpPotionEffects) {</b>
<b class="nc">&nbsp;				for (int i = 0; i &lt; effects.length; i++) {</b>
<b class="nc">&nbsp;					PotionType pType = effects[i].getKey();</b>
<b class="nc">&nbsp;					int pTime = effects[i].getValue() / Updater.normSpeed;</b>
<b class="nc">&nbsp;					int minutes = pTime / 60;</b>
<b class="nc">&nbsp;					int seconds = pTime % 60;</b>
<b class="nc">&nbsp;					Font.drawBackground(Localization.getLocalized(&quot;minicraft.display.gui.potion_effects.hide_hint&quot;, input.getMapping(&quot;potionEffects&quot;)), screen, 180, 9);</b>
<b class="nc">&nbsp;					Font.drawBackground(Localization.getLocalized(&quot;minicraft.display.gui.potion_effects.potion_dur&quot;, pType, minutes, seconds), screen, 180, 17 + i * Font.textHeight() + potionRenderOffset, pType.dispColor);</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				for (int i = 0; i &lt; effects.length; i++) {</b>
<b class="nc">&nbsp;					PotionType pType = effects[i].getKey();</b>
<b class="nc">&nbsp;					Font.drawBackground(pType.toString().substring(0, 1), screen, Screen.w - 17 - (effects.length - 1 - i) * 8, 9, pType.dispColor);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// This is the status icons, like health hearts, stamina bolts, and hunger &quot;burgers&quot;.
<b class="nc">&nbsp;		if (!isMode(&quot;minicraft.settings.mode.creative&quot;)) {</b>
<b class="nc">&nbsp;			for (int i = 1; i &lt;= 30; i++) {</b>
&nbsp;				// Renders your current red default hearts, golden hearts for 20 HP, obsidian hearts for 30 HP, or black hearts for damaged health.
<b class="nc">&nbsp;				if (i &lt; 11) {</b>
<b class="nc">&nbsp;					screen.render((i - 1) * 8, Screen.h - 16, 0, 1, 0, hudSheet.getSheet()); // Empty Hearts</b>
&nbsp;				}
<b class="nc">&nbsp;				if (i &lt; player.health + 1 &amp;&amp; i &lt; 11) {</b>
<b class="nc">&nbsp;					screen.render((i - 1) * 8, Screen.h - 16, 0, 0, 0, hudSheet.getSheet());  // Red Hearts</b>
&nbsp;				}
<b class="nc">&nbsp;				if (i &lt; player.health + 1 &amp;&amp; i &lt; 21 &amp;&amp; i &gt;= 11) {</b>
<b class="nc">&nbsp;					screen.render((i - 11) * 8, Screen.h - 16, 0, 2, 0, hudSheet.getSheet()); // Yellow Hearts</b>
&nbsp;				}
<b class="nc">&nbsp;				if (i &lt; player.health + 1 &amp;&amp; i &gt;= 21) {</b>
<b class="nc">&nbsp;					screen.render((i - 21) * 8, Screen.h - 16, 0, 3, 0, hudSheet.getSheet()); // Obsidian Hearts</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			for (int i = 0; i &lt; Player.maxStat; i++) {</b>
&nbsp;
&nbsp;				// Renders armor
<b class="nc">&nbsp;				int armor = player.armor * Player.maxStat / Player.maxArmor;</b>
<b class="nc">&nbsp;				if (i &lt;= armor &amp;&amp; player.curArmor != null) {</b>
<b class="nc">&nbsp;					screen.render(i * 8, Screen.h - 24, player.curArmor.sprite);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				if (player.staminaRechargeDelay &gt; 0) {</b>
&nbsp;					// Creates the white/gray blinking effect when you run out of stamina.
<b class="nc">&nbsp;					if (player.staminaRechargeDelay / 4 % 2 == 0) {</b>
<b class="nc">&nbsp;						screen.render(i * 8, Screen.h - 8, 1, 2, 0, hudSheet.getSheet());</b>
&nbsp;					} else {
<b class="nc">&nbsp;						screen.render(i * 8, Screen.h - 8, 1, 1, 0, hudSheet.getSheet());</b>
&nbsp;					}
&nbsp;				} else {
&nbsp;					// Renders your current stamina, and uncharged gray stamina.
<b class="nc">&nbsp;					if (i &lt; player.stamina) {</b>
<b class="nc">&nbsp;						screen.render(i * 8, Screen.h - 8, 1, 0, 0, hudSheet.getSheet());</b>
&nbsp;					} else {
<b class="nc">&nbsp;						screen.render(i * 8, Screen.h - 8, 1, 1, 0, hudSheet.getSheet());</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;				// Renders hunger
<b class="nc">&nbsp;				if (i &lt; player.hunger) {</b>
<b class="nc">&nbsp;					screen.render(i * 8 + (Screen.w - 80), Screen.h - 16, 2, 0, 0, hudSheet.getSheet());</b>
&nbsp;				} else {
<b class="nc">&nbsp;					screen.render(i * 8 + (Screen.w - 80), Screen.h - 16, 2, 1, 0, hudSheet.getSheet());</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// Renders the bossbar
<b class="nc">&nbsp;		if (!player.isRemoved()) {</b>
<b class="nc">&nbsp;			if (AirWizard.active &amp;&amp; (player.getLevel().depth == 1)) {</b>
<b class="nc">&nbsp;				AirWizard boss = AirWizard.entity;</b>
<b class="nc">&nbsp;				renderBossbar((int) ((((float) boss.health) / boss.maxHealth) * 100), &quot;Air wizard&quot;);</b>
<b class="nc">&nbsp;			} else if (ObsidianKnight.active &amp;&amp; (player.getLevel().depth == -4)) {</b>
<b class="nc">&nbsp;				ObsidianKnight boss = ObsidianKnight.entity;</b>
<b class="nc">&nbsp;				renderBossbar((int) ((((float) boss.health) / boss.maxHealth) * 100), &quot;Obsidian Knight&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		TutorialDisplayHandler.render(screen);</b>
<b class="nc">&nbsp;		renderQuestsDisplay();</b>
<b class="nc">&nbsp;		if (signDisplayMenu != null) signDisplayMenu.render(screen);</b>
<b class="nc">&nbsp;		renderDebugInfo();</b>
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	public static void renderBossbar(int length, String title) {
&nbsp;
<b class="nc">&nbsp;		int x = Screen.w / 4 - 24;</b>
<b class="nc">&nbsp;		int y = Screen.h / 8 - 24;</b>
&nbsp;
<b class="nc">&nbsp;		int max_bar_length = 100;</b>
<b class="nc">&nbsp;		int bar_length = length; // Bossbar size.</b>
&nbsp;
<b class="nc">&nbsp;		int INACTIVE_BOSSBAR = 4; // sprite x position</b>
<b class="nc">&nbsp;		int ACTIVE_BOSSBAR = 5; // sprite x position</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;		screen.render(x + (max_bar_length * 2), y, 0, INACTIVE_BOSSBAR, 1, hudSheet.getSheet()); // left corner</b>
&nbsp;
&nbsp;		// The middle
<b class="nc">&nbsp;		for (int bx = 0; bx &lt; max_bar_length; bx++) {</b>
<b class="nc">&nbsp;			for (int by = 0; by &lt; 1; by++) {</b>
<b class="nc">&nbsp;				screen.render(x + bx * 2, y + by * 8, 3, INACTIVE_BOSSBAR, 0, hudSheet.getSheet());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		screen.render(x - 5, y, 0, ACTIVE_BOSSBAR, 0, hudSheet.getSheet()); // right corner</b>
&nbsp;
<b class="nc">&nbsp;		for (int bx = 0; bx &lt; bar_length; bx++) {</b>
<b class="nc">&nbsp;			for (int by = 0; by &lt; 1; by++) {</b>
<b class="nc">&nbsp;				screen.render(x + bx * 2, y + by * 8, 3, ACTIVE_BOSSBAR, 0, hudSheet.getSheet());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		Font.drawCentered(title, screen, y + 8, Color.WHITE);</b>
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	private static void renderQuestsDisplay() {
<b class="nc">&nbsp;		if (!TutorialDisplayHandler.inQuests()) return;</b>
<b class="nc">&nbsp;		if (!(boolean) Settings.get(&quot;showquests&quot;)) return;</b>
&nbsp;
<b class="nc">&nbsp;		boolean expanding = Game.player.questExpanding &gt; 0;</b>
<b class="nc">&nbsp;		int length = expanding ? 5 : 2;</b>
<b class="nc">&nbsp;		ArrayList&lt;ListEntry&gt; questsShown = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		HashSet&lt;Quest&gt; quests = QuestsDisplay.getDisplayableQuests();</b>
<b class="nc">&nbsp;		for (Quest q : quests) {</b>
<b class="nc">&nbsp;			QuestSeries series = q.getSeries();</b>
&nbsp;
<b class="nc">&nbsp;			questsShown.add(!expanding ?</b>
<b class="nc">&nbsp;				new StringEntry(Localization.getLocalized(q.key), Color.WHITE, false) :</b>
<b class="nc">&nbsp;				new StringEntry(q.shouldAllCriteriaBeCompleted() &amp;&amp; q.getTotalNumCriteria() &gt; 1 ?</b>
<b class="nc">&nbsp;					String.format(&quot;%s (%d/%d)&quot;, Localization.getLocalized(series.key), q.getNumCriteriaCompleted(), q.getTotalNumCriteria()) :</b>
<b class="nc">&nbsp;					Localization.getLocalized(series.key), Color.WHITE, false)</b>
&nbsp;			);
&nbsp;
<b class="nc">&nbsp;			if (questsShown.size() &gt;= length) break;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		if (questsShown.size() &gt; 0) {</b>
<b class="nc">&nbsp;			potionRenderOffset = 9 + (Math.min(questsShown.size(), 3)) * 8 + 8 * 2;</b>
<b class="nc">&nbsp;			new Menu.Builder(true, 0, RelPos.RIGHT, questsShown)</b>
<b class="nc">&nbsp;				.setPositioning(new Point(Screen.w - 9, 9), RelPos.BOTTOM_LEFT)</b>
<b class="nc">&nbsp;				.setTitle(&quot;Quests&quot;)</b>
<b class="nc">&nbsp;				.createMenu()</b>
<b class="nc">&nbsp;				.render(screen);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			potionRenderOffset = 0;</b>
&nbsp;		}
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	private static void renderDebugInfo() {
&nbsp;		// Should not localize debug info.
&nbsp;
<b class="nc">&nbsp;		int textcol = Color.WHITE;</b>
&nbsp;
<b class="nc">&nbsp;		if (showDebugInfo) { // Renders show debug info on the screen.</b>
<b class="nc">&nbsp;			ArrayList&lt;String&gt; info = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;			info.add(&quot;VERSION: &quot; + Initializer.VERSION);</b>
<b class="nc">&nbsp;			info.add(Initializer.fra + &quot; fps&quot;);</b>
<b class="nc">&nbsp;			info.add(&quot;Day tiks: &quot; + Updater.tickCount + &quot; (&quot; + Updater.getTime() + &quot;)&quot;);</b>
<b class="nc">&nbsp;			info.add((Updater.normSpeed * Updater.gamespeed) + &quot; tps&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			info.add(&quot;walk spd: &quot; + player.moveSpeed);</b>
<b class="nc">&nbsp;			info.add(&quot;X: &quot; + (player.x / 16) + &quot;-&quot; + (player.x % 16));</b>
<b class="nc">&nbsp;			info.add(&quot;Y: &quot; + (player.y / 16) + &quot;-&quot; + (player.y % 16));</b>
<b class="nc">&nbsp;			if (levels[currentLevel] != null)</b>
<b class="nc">&nbsp;				info.add(&quot;Tile: &quot; + levels[currentLevel].getTile(player.x &gt;&gt; 4, player.y &gt;&gt; 4).name);</b>
<b class="nc">&nbsp;			if (isMode(&quot;minicraft.settings.mode.score&quot;)) info.add(&quot;Score: &quot; + player.getScore());</b>
&nbsp;
<b class="nc">&nbsp;			if (levels[currentLevel] != null) {</b>
<b class="nc">&nbsp;				info.add(&quot;Mob Cnt: &quot; + levels[currentLevel].mobCount + &quot;/&quot; + levels[currentLevel].maxMobCount);</b>
&nbsp;			}
&nbsp;
&nbsp;			// Displays number of chests left, if on dungeon level.
<b class="nc">&nbsp;			if (levels[currentLevel] != null &amp;&amp; currentLevel == 5) {</b>
<b class="nc">&nbsp;				if (levels[5].chestCount &gt; 0)</b>
<b class="nc">&nbsp;					info.add(&quot;Chests: &quot; + levels[5].chestCount);</b>
&nbsp;				else
<b class="nc">&nbsp;					info.add(&quot;Chests: Complete!&quot;);</b>
&nbsp;			}
&nbsp;
&nbsp;
<b class="nc">&nbsp;			info.add(&quot;Hunger stam: &quot; + player.getDebugHunger());</b>
<b class="nc">&nbsp;			if (player.armor &gt; 0) {</b>
<b class="nc">&nbsp;				info.add(&quot;Armor: &quot; + player.armor);</b>
<b class="nc">&nbsp;				info.add(&quot;Dam buffer: &quot; + player.armorDamageBuffer);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (levels[currentLevel] != null) {</b>
<b class="nc">&nbsp;				info.add(&quot;Seed: &quot; + levels[currentLevel].getSeed());</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			FontStyle style = new FontStyle(textcol).setShadowType(Color.BLACK, true).setXPos(1);</b>
<b class="nc">&nbsp;			style.setYPos(2);</b>
<b class="nc">&nbsp;			Font.drawParagraph(info, screen, style, 2);</b>
&nbsp;		}
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Renders the &quot;Click to focus&quot; box when you click off the screen.
&nbsp;	 */
&nbsp;	private static void renderFocusNagger() {
&nbsp;
<b class="nc">&nbsp;		String msg = &quot;Click to focus!&quot;; // The message when you click off the screen.</b>
&nbsp;
<b class="nc">&nbsp;		Updater.paused = true; // Perhaps paused is only used for this.</b>
<b class="nc">&nbsp;		int xx = (Screen.w - Font.textWidth(msg)) / 2; // The width of the box</b>
<b class="nc">&nbsp;		int yy = (HEIGHT - 8) / 2; // The height of the box</b>
<b class="nc">&nbsp;		int w = msg.length(); // Length of message in characters.</b>
<b class="nc">&nbsp;		int h = 1;</b>
&nbsp;
&nbsp;		// Renders the four corners of the box
<b class="nc">&nbsp;		screen.render(xx - 8, yy - 8, 0, 6, 0, hudSheet.getSheet());</b>
<b class="nc">&nbsp;		screen.render(xx + w * 8, yy - 8, 0, 6, 1, hudSheet.getSheet());</b>
<b class="nc">&nbsp;		screen.render(xx - 8, yy + 8, 0, 6, 2, hudSheet.getSheet());</b>
<b class="nc">&nbsp;		screen.render(xx + w * 8, yy + 8, 0, 6, 3, hudSheet.getSheet());</b>
&nbsp;
&nbsp;		// Renders each part of the box...
<b class="nc">&nbsp;		for (int x = 0; x &lt; w; x++) {</b>
<b class="nc">&nbsp;			screen.render(xx + x * 8, yy - 8, 1, 6, 0, hudSheet.getSheet()); // ...Top part</b>
<b class="nc">&nbsp;			screen.render(xx + x * 8, yy + 8, 1, 6, 2, hudSheet.getSheet()); // ...Bottom part</b>
&nbsp;		}
<b class="nc">&nbsp;		for (int y = 0; y &lt; h; y++) {</b>
<b class="nc">&nbsp;			screen.render(xx - 8, yy + y * 8, 2, 6, 0, hudSheet.getSheet()); // ...Left part</b>
<b class="nc">&nbsp;			screen.render(xx + w * 8, yy + y * 8, 2, 6, 1, hudSheet.getSheet()); // ...Right part</b>
&nbsp;		}
&nbsp;
&nbsp;		// The middle
<b class="nc">&nbsp;		for (int x = 0; x &lt; w; x++) {</b>
<b class="nc">&nbsp;			screen.render(xx + x * 8, yy, 3, 6, 0, hudSheet.getSheet());</b>
&nbsp;		}
&nbsp;
&nbsp;		// Renders the focus nagger text with a flash effect...
<b class="nc">&nbsp;		if ((Updater.tickCount / 20) % 2 == 0) // ...Medium yellow color</b>
<b class="nc">&nbsp;			Font.draw(msg, screen, xx, yy, Color.get(1, 153));</b>
&nbsp;		else // ...Bright yellow color
<b class="nc">&nbsp;			Font.draw(msg, screen, xx, yy, Color.get(5, 255));</b>
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;
&nbsp;	static java.awt.Dimension getWindowSize() {
<b class="nc">&nbsp;		return new java.awt.Dimension((int) (WIDTH * SCALE), (int) (HEIGHT * SCALE));</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-19 15:54</div>
</div>
</body>
</html>
