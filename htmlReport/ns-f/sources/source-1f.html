


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > SkinDisplay</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">minicraft.screen</a>
</div>

<h1>Coverage Summary for Class: SkinDisplay (minicraft.screen)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SkinDisplay</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/112)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SkinDisplay$WatcherThread</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/140)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package minicraft.screen;
&nbsp;
&nbsp;import minicraft.core.CrashHandler;
&nbsp;import minicraft.core.Game;
&nbsp;import minicraft.core.Renderer;
&nbsp;import minicraft.core.io.FileHandler;
&nbsp;import minicraft.core.io.InputHandler;
&nbsp;import minicraft.core.io.Localization;
&nbsp;import minicraft.entity.mob.Mob;
&nbsp;import minicraft.gfx.Color;
&nbsp;import minicraft.gfx.Font;
&nbsp;import minicraft.gfx.MinicraftImage;
&nbsp;import minicraft.gfx.Point;
&nbsp;import minicraft.gfx.Screen;
&nbsp;import minicraft.gfx.SpriteLinker.LinkedSprite;
&nbsp;import minicraft.saveload.Save;
&nbsp;import minicraft.screen.entry.ListEntry;
&nbsp;import minicraft.screen.entry.SelectEntry;
&nbsp;import minicraft.util.Logging;
&nbsp;import org.jetbrains.annotations.NotNull;
&nbsp;
&nbsp;import javax.imageio.ImageIO;
&nbsp;import javax.security.auth.DestroyFailedException;
&nbsp;
&nbsp;import java.awt.image.BufferedImage;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.*;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;/**
&nbsp; * The skins are put in a folder generated by the game called &quot;skins&quot;.
&nbsp; * Many skins can be put according to the number of files.
&nbsp; */
<b class="nc">&nbsp;public class SkinDisplay extends Display {</b>
<b class="nc">&nbsp;	private static final LinkedHashMap&lt;String, LinkedSprite[][]&gt; skins = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;	private static final ArrayList&lt;String&gt; defaultSkins = new ArrayList&lt;&gt;();</b>
&nbsp;	private static final MinicraftImage defaultSheet;
<b class="nc">&nbsp;	private static final File FOLDER_LOCATION = new File(FileHandler.gameDir + &quot;/skins&quot;);</b>
&nbsp;	private static String selectedSkin;
&nbsp;
&nbsp;	private int step;
&nbsp;	private WatcherThread thread;
&nbsp;
&nbsp;	static {
&nbsp;		// Load the default sprite sheet.
<b class="nc">&nbsp;		defaultSheet = Renderer.loadDefaultSkinSheet();</b>
&nbsp;
&nbsp;		// These are all the generic skins. To add one, just add an entry in this list.
<b class="nc">&nbsp;		defaultSkins.add(&quot;minicraft.skin.paul&quot;);</b>
<b class="nc">&nbsp;		defaultSkins.add(&quot;minicraft.skin.paul_cape&quot;);</b>
<b class="nc">&nbsp;		defaultSkins.add(&quot;minicraft.skin.minecraft_steve&quot;);</b>
<b class="nc">&nbsp;		defaultSkins.add(&quot;minicraft.skin.minecraft_alex&quot;);</b>
<b class="nc">&nbsp;		selectedSkin = defaultSkins.get(0);</b>
&nbsp;
<b class="nc">&nbsp;		Logging.RESOURCEHANDLER_SKIN.debug(&quot;Refreshing skins.&quot;);</b>
<b class="nc">&nbsp;		refreshSkins();</b>
&nbsp;	}
&nbsp;
&nbsp;	public SkinDisplay() {
<b class="nc">&nbsp;		super(true, true,</b>
&nbsp;			new Menu.Builder(false, 2, RelPos.CENTER)
<b class="nc">&nbsp;				.setDisplayLength(8)</b>
<b class="nc">&nbsp;				.setSelectable(true)</b>
<b class="nc">&nbsp;				.setPositioning(new Point(Screen.w / 2, Screen.h * 3 / 5), RelPos.CENTER)</b>
<b class="nc">&nbsp;				.createMenu()</b>
&nbsp;		);
&nbsp;
<b class="nc">&nbsp;		thread = new WatcherThread();</b>
<b class="nc">&nbsp;		refreshSkins();</b>
<b class="nc">&nbsp;		refreshEntries();</b>
<b class="nc">&nbsp;		menus[0].setSelection(new ArrayList&lt;&gt;(skins.keySet()).indexOf(selectedSkin));</b>
&nbsp;	}
&nbsp;
&nbsp;	public static void refreshSkins() {
<b class="nc">&nbsp;		Renderer.spriteLinker.clearSkins();</b>
<b class="nc">&nbsp;		skins.clear();</b>
&nbsp;
&nbsp;		// Pointing the keys to the default sheet,
<b class="nc">&nbsp;		Renderer.spriteLinker.setSkin(&quot;skin.minicraft.skin.paul&quot;, defaultSheet);</b>
<b class="nc">&nbsp;		Renderer.spriteLinker.setSkin(&quot;skin.minicraft.skin.paul_cape&quot;, defaultSheet);</b>
<b class="nc">&nbsp;		Renderer.spriteLinker.setSkin(&quot;skin.minicraft.skin.minecraft_steve&quot;, defaultSheet);</b>
<b class="nc">&nbsp;		Renderer.spriteLinker.setSkin(&quot;skin.minicraft.skin.minecraft_alex&quot;, defaultSheet);</b>
&nbsp;
<b class="nc">&nbsp;		skins.put(&quot;minicraft.skin.paul&quot;, Mob.compileMobSpriteAnimations(0, 0, &quot;skin.minicraft.skin.paul&quot;));</b>
<b class="nc">&nbsp;		skins.put(&quot;minicraft.skin.paul_cape&quot;, Mob.compileMobSpriteAnimations(0, 4, &quot;skin.minicraft.skin.paul_cape&quot;));</b>
<b class="nc">&nbsp;		skins.put(&quot;minicraft.skin.minecraft_steve&quot;, Mob.compileMobSpriteAnimations(0, 8, &quot;skin.minicraft.skin.minecraft_steve&quot;));</b>
<b class="nc">&nbsp;		skins.put(&quot;minicraft.skin.minecraft_alex&quot;, Mob.compileMobSpriteAnimations(0, 12, &quot;skin.minicraft.skin.minecraft_alex&quot;));</b>
&nbsp;
&nbsp;		// Create folder, and see if it was successful.
<b class="nc">&nbsp;		if (FOLDER_LOCATION.mkdirs()) {</b>
<b class="nc">&nbsp;			Logging.RESOURCEHANDLER_SKIN.info(&quot;Created skin folder at {}.&quot;, FOLDER_LOCATION);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Read and add the .png file to the skins list.
<b class="nc">&nbsp;		ArrayList&lt;File&gt; files = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		for (String skinPath : Objects.requireNonNull(FOLDER_LOCATION.list())) {</b>
<b class="nc">&nbsp;			if (skinPath.endsWith(&quot;.png&quot;)) {</b>
<b class="nc">&nbsp;				files.add(new File(FOLDER_LOCATION, skinPath));</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		refreshSkinFiles(files);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void refreshEntries() {
<b class="nc">&nbsp;		List&lt;ListEntry&gt; l = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		for (String s : skins.keySet()) {</b>
<b class="nc">&nbsp;			l.add(new SelectEntry(s, this::confirmExit));</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		menus[0].setEntries(l);</b>
<b class="nc">&nbsp;		menus[0].setSelection(menus[0].getSelection());</b>
&nbsp;	}
&nbsp;
&nbsp;	public static void releaseSkins() {
<b class="nc">&nbsp;		for (String skin : new ArrayList&lt;&gt;(skins.keySet())) {</b>
<b class="nc">&nbsp;			if (!defaultSkins.contains(skin) &amp;&amp; !skin.equals(selectedSkin)) {</b>
<b class="nc">&nbsp;				Renderer.spriteLinker.setSkin(&quot;skin.&quot; + skin, null);</b>
<b class="nc">&nbsp;				if (skins.containsKey(skin)) for (LinkedSprite[] a : skins.remove(skin)) {</b>
<b class="nc">&nbsp;					for (LinkedSprite b : a) {</b>
&nbsp;						try {
<b class="nc">&nbsp;							b.destroy();</b>
<b class="nc">&nbsp;						} catch (DestroyFailedException e) {</b>
<b class="nc">&nbsp;							Logging.RESOURCEHANDLER_SKIN.trace(e);</b>
<b class="nc">&nbsp;						}</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Watching the directory changes. Allowing hot-loading.
&nbsp;	 */
&nbsp;	private class WatcherThread extends Thread {
&nbsp;		private WatchService watcher;
<b class="nc">&nbsp;		private volatile Thread running = this;</b>
&nbsp;
<b class="nc">&nbsp;		WatcherThread() {</b>
<b class="nc">&nbsp;			super(&quot;Skin File Watcher&quot;);</b>
&nbsp;			try {
<b class="nc">&nbsp;				watcher = FileSystems.getDefault().newWatchService();</b>
<b class="nc">&nbsp;				FOLDER_LOCATION.toPath().register(watcher, StandardWatchEventKinds.ENTRY_CREATE,</b>
&nbsp;					StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				CrashHandler.errorHandle(e, new CrashHandler.ErrorInfo(&quot;Unable to Watch File&quot;, CrashHandler.ErrorInfo.ErrorType.UNHANDLEABLE, &quot;Unable to create file water service.&quot;));</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			start();</b>
<b class="nc">&nbsp;			Logging.RESOURCEHANDLER_SKIN.debug(&quot;WatcherThread started.&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void run() {
<b class="nc">&nbsp;			while (running == this) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					ArrayList&lt;File&gt; files = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;					for (WatchEvent&lt;?&gt; event : watcher.take().pollEvents()) {</b>
<b class="nc">&nbsp;						if (event.kind() == StandardWatchEventKinds.OVERFLOW)</b>
<b class="nc">&nbsp;							continue;</b>
&nbsp;
&nbsp;						@SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;						WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event;</b>
<b class="nc">&nbsp;						Path filename = ev.context();</b>
<b class="nc">&nbsp;						files.add(FOLDER_LOCATION.toPath().resolve(filename).toFile());</b>
<b class="nc">&nbsp;					}</b>
&nbsp;
<b class="nc">&nbsp;					if (files.size() &gt; 0) {</b>
<b class="nc">&nbsp;						Logging.RESOURCEHANDLER_SKIN.debug(&quot;Refreshing resource packs.&quot;);</b>
<b class="nc">&nbsp;						refreshSkinFiles(files);</b>
<b class="nc">&nbsp;						refreshEntries();</b>
&nbsp;					}
<b class="nc">&nbsp;				} catch (InterruptedException e) {</b>
<b class="nc">&nbsp;					Logging.RESOURCEHANDLER_SKIN.trace(&quot;File watcher terminated.&quot;);</b>
&nbsp;					return;
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			Logging.RESOURCEHANDLER_SKIN.trace(&quot;File watcher terminated.&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		public void close() {
<b class="nc">&nbsp;			running = null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private synchronized static void refreshSkinFiles(List&lt;File&gt; files) {
<b class="nc">&nbsp;		for (File file : files) {</b>
<b class="nc">&nbsp;			String skinPath = file.getName();</b>
<b class="nc">&nbsp;			String name = skinPath.substring(0, skinPath.length() - 4);</b>
<b class="nc">&nbsp;			if (file.exists()) try {</b>
<b class="nc">&nbsp;				BufferedImage img = ImageIO.read(Files.newInputStream(file.toPath()));</b>
<b class="nc">&nbsp;				MinicraftImage.validateImageDimension(img);</b>
<b class="nc">&nbsp;				MinicraftImage.validateImageDimension(img, 64, 32);</b>
<b class="nc">&nbsp;				MinicraftImage sheet = new MinicraftImage(img, 64, 32);</b>
<b class="nc">&nbsp;				Renderer.spriteLinker.setSkin(&quot;skin.&quot; + name, sheet);</b>
<b class="nc">&nbsp;				skins.put(name, Mob.compileMobSpriteAnimations(0, 0, &quot;skin.&quot; + name));</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				Logging.RESOURCEHANDLER_SKIN.error(&quot;Could not read image at path {}. The file is probably missing or formatted wrong.&quot;, skinPath);</b>
<b class="nc">&nbsp;			} catch (SecurityException e) {</b>
<b class="nc">&nbsp;				Logging.RESOURCEHANDLER_SKIN.error(&quot;Access to file located at {} was denied. Check if game is given permission.&quot;, skinPath);</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (MinicraftImage.MinicraftImageRequestOutOfBoundsException e) {</b>
<b class="nc">&nbsp;				Logging.RESOURCEHANDLER_SKIN.warn(&quot;Potentially incompatible image at {}:\n&quot; +</b>
&nbsp;					&quot;Source: width {}; height {}\nRequested: width {}; height {}&quot;, skinPath,
<b class="nc">&nbsp;					e.getSourceWidth(), e.getSourceHeight(), e.getRequestedWidth(), e.getRequestedHeight());</b>
<b class="nc">&nbsp;			} catch (MinicraftImage.MinicraftImageDimensionIncompatibleException e) {</b>
<b class="nc">&nbsp;				Logging.RESOURCEHANDLER_SKIN.warn(&quot;Potentially incompatible image at {}:\n&quot; +</b>
<b class="nc">&nbsp;					&quot;Source: width {}; height {}&quot;, skinPath, e.getWidth(), e.getHeight());</b>
<b class="nc">&nbsp;			} else {</b>
<b class="nc">&nbsp;				Renderer.spriteLinker.setSkin(&quot;skin.&quot; + name, null);</b>
<b class="nc">&nbsp;				if (skins.containsKey(name)) for (LinkedSprite[] a : skins.remove(name)) {</b>
<b class="nc">&nbsp;					for (LinkedSprite b : a) {</b>
&nbsp;						try {
<b class="nc">&nbsp;							b.destroy();</b>
<b class="nc">&nbsp;						} catch (DestroyFailedException e) {</b>
<b class="nc">&nbsp;							Logging.RESOURCEHANDLER_SKIN.trace(e);</b>
<b class="nc">&nbsp;						}</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * If we exited by selecting a skin.
&nbsp;	 */
&nbsp;	private void confirmExit() {
<b class="nc">&nbsp;		Game.exitDisplay();</b>
<b class="nc">&nbsp;		selectedSkin = new ArrayList&lt;&gt;(skins.keySet()).get(menus[0].getSelection());</b>
&nbsp;
&nbsp;		// Achieve Fashion Show:
<b class="nc">&nbsp;		AchievementsDisplay.setAchievement(true, &quot;minicraft.achievement.skin&quot;, true);</b>
&nbsp;
&nbsp;		// Tell the player to apply changes.
<b class="nc">&nbsp;		if (Game.player != null) {</b>
<b class="nc">&nbsp;			Game.player.updateSprites();</b>
&nbsp;		}
&nbsp;
&nbsp;		// Save the selected skin.
<b class="nc">&nbsp;		new Save();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void onExit() {
<b class="nc">&nbsp;		thread.close();</b>
<b class="nc">&nbsp;		releaseSkins();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void tick(InputHandler input) {
<b class="nc">&nbsp;		super.tick(input);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void render(Screen screen) {
<b class="nc">&nbsp;		super.render(screen);</b>
<b class="nc">&nbsp;		step++;</b>
&nbsp;
&nbsp;		// Title.
<b class="nc">&nbsp;		Font.drawCentered(Localization.getLocalized(&quot;minicraft.displays.skin&quot;), screen, 16, Color.WHITE);</b>
&nbsp;
<b class="nc">&nbsp;		int xOffset = Screen.w / 2 - 8; // Put this in the center of the screen</b>
<b class="nc">&nbsp;		int yOffset = 40; // Player sprite Y position</b>
&nbsp;
<b class="nc">&nbsp;		int spriteIndex = (step / 40) % 8; // 9 = 8 Frames for sprite</b>
&nbsp;
&nbsp;		// Render preview of skin.
<b class="nc">&nbsp;		LinkedSprite sprite = new ArrayList&lt;&gt;(skins.values()).get(menus[0].getSelection())[spriteIndex / 2][spriteIndex % 2];</b>
<b class="nc">&nbsp;		screen.render(xOffset, yOffset, sprite);</b>
&nbsp;
&nbsp;		// Help text.
<b class="nc">&nbsp;		Font.drawCentered(Localization.getLocalized(&quot;minicraft.displays.resource_packs.display.help.move&quot;, Game.input.getMapping(&quot;cursor-down&quot;), Game.input.getMapping(&quot;cursor-up&quot;)), screen, Screen.h - 17, Color.DARK_GRAY);</b>
<b class="nc">&nbsp;		Font.drawCentered(Localization.getLocalized(&quot;minicraft.displays.skin.display.help.select&quot;, Game.input.getMapping(&quot;SELECT&quot;), Game.input.getMapping(&quot;EXIT&quot;)), screen, Screen.h - 9, Color.DARK_GRAY);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static String getSelectedSkin() {
<b class="nc">&nbsp;		return selectedSkin;</b>
&nbsp;	}
&nbsp;
&nbsp;	public static void setSelectedSkin(String selectedSkin) {
<b class="nc">&nbsp;		SkinDisplay.selectedSkin = selectedSkin;</b>
&nbsp;	}
&nbsp;
&nbsp;	// First array is one of the four animations.
&nbsp;	@NotNull
&nbsp;	public static LinkedSprite[][][] getSkinAsMobSprite() {
<b class="nc">&nbsp;		LinkedSprite[][][] mobSprites = new LinkedSprite[2][][];</b>
&nbsp;
<b class="nc">&nbsp;		if (!skins.keySet().contains(selectedSkin)) selectedSkin = defaultSkins.get(0);</b>
<b class="nc">&nbsp;		if (defaultSkins.contains(selectedSkin)) {</b>
<b class="nc">&nbsp;			mobSprites[0] = Mob.compileMobSpriteAnimations(0, defaultSkins.indexOf(selectedSkin) * 4, &quot;skin.&quot; + selectedSkin);</b>
<b class="nc">&nbsp;			mobSprites[1] = Mob.compileMobSpriteAnimations(0, defaultSkins.indexOf(selectedSkin) * 4 + 2, &quot;skin.&quot; + selectedSkin);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			mobSprites[0] = Mob.compileMobSpriteAnimations(0, 0, &quot;skin.&quot; + selectedSkin);</b>
<b class="nc">&nbsp;			mobSprites[1] = Mob.compileMobSpriteAnimations(0, 2, &quot;skin.&quot; + selectedSkin);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return mobSprites;</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-19 17:20</div>
</div>
</body>
</html>
